{"version":3,"file":"index.development.js","sources":["../../src/createBaseQuery.ts","../../src/utils.ts","../../src/createInfiniteQuery.ts","../../src/createMutation.ts","../../src/createQuery.tsx"],"sourcesContent":["import type { SetDataOptions, UseBaseQueryOptions } from '@tanstack/react-query'\nimport { useQueryClient } from '@tanstack/react-query'\nimport type { Updater } from '@tanstack/react-query/build/types/packages/query-core/src/utils'\nimport type {\n  AdditionalCreateOptions,\n  AdditionalQueryHookOptions,\n} from './types'\n\ninterface CreateQueryOptions\n  extends Omit<\n      UseBaseQueryOptions,\n      'queryKey' | 'queryFn' | 'enabled' | 'select'\n    >,\n    AdditionalCreateOptions<any, any> {}\n\ntype QueryBaseHookOptions = Omit<\n  UseBaseQueryOptions,\n  'queryKey' | 'queryFn' | 'enabled'\n> &\n  AdditionalQueryHookOptions<any, any>\n\nexport function createBaseQuery(\n  options: CreateQueryOptions,\n  hook: (options: any) => any\n): any {\n  const { primaryKey, queryFn, ...defaultOptions } = options\n\n  const getPrimaryKey = () => primaryKey\n\n  const getKey = (variables?: any) =>\n    typeof variables === 'undefined' ? [primaryKey] : [primaryKey, variables]\n\n  function useGeneratedQuery(options?: QueryBaseHookOptions) {\n    const { variables, ...restOptions } = options || {}\n\n    const queryKey = getKey(variables)\n\n    const { enabled, ...mergedOptions } = {\n      ...defaultOptions,\n      ...restOptions,\n      queryFn,\n      queryKey,\n    }\n\n    const queryClient = useQueryClient({ context: mergedOptions.context })\n\n    const setData = (updater: Updater<any, any>, options?: SetDataOptions) =>\n      queryClient.setQueryData(queryKey, updater, options)\n\n    const result = hook({\n      ...mergedOptions,\n      enabled:\n        typeof enabled === 'function'\n          ? enabled(queryClient.getQueryData(queryKey))\n          : enabled,\n    })\n\n    return Object.assign(result, { setData })\n  }\n\n  useGeneratedQuery.getPrimaryKey = getPrimaryKey\n  useGeneratedQuery.getKey = getKey\n  useGeneratedQuery.queryFn = queryFn\n\n  return useGeneratedQuery\n}\n","import type { QueryFunction } from '@tanstack/react-query'\n\nexport function parseQueryKitArgs<TOptions extends Record<any, any>>(\n  arg1: string | TOptions,\n  arg2?: QueryFunction<any, any> | TOptions,\n  arg3?: TOptions\n): TOptions {\n  if (typeof arg1 !== 'string') {\n    return arg1 as TOptions\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3, primaryKey: arg1, queryFn: arg2 } as unknown as TOptions\n  }\n\n  return { ...arg2, primaryKey: arg1 } as unknown as TOptions\n}\n","import type {\n  InfiniteData,\n  QueryFunction,\n  SetDataOptions,\n  UseInfiniteQueryOptions,\n  UseInfiniteQueryResult,\n} from '@tanstack/react-query'\nimport { useInfiniteQuery } from '@tanstack/react-query'\nimport type { Updater } from '@tanstack/react-query/build/types/packages/query-core/src/utils'\nimport { createBaseQuery } from './createBaseQuery'\nimport type {\n  AdditionalCreateOptions,\n  AdditionalQueryHookOptions,\n  ExposeMethods,\n  QueryKitKey,\n} from './types'\nimport { parseQueryKitArgs } from './utils'\n\ninterface CreateInfiniteQueryOptions<TFnData, TVariables, Error>\n  extends Omit<\n      UseInfiniteQueryOptions<\n        TFnData,\n        Error,\n        unknown,\n        TFnData,\n        QueryKitKey<TVariables>\n      >,\n      'queryKey' | 'queryFn' | 'enabled' | 'select'\n    >,\n    AdditionalCreateOptions<TFnData, TVariables> {}\n\ntype InfiniteQueryHookOptions<TFnData, Error, TData, TVariables> = Omit<\n  UseInfiniteQueryOptions<\n    TFnData,\n    Error,\n    TData,\n    TFnData,\n    QueryKitKey<TVariables>\n  >,\n  'queryKey' | 'queryFn' | 'enabled'\n> &\n  AdditionalQueryHookOptions<TFnData, TVariables>\n\ninterface InfiniteQueryHook<TFnData, TVariables = void, Error = unknown>\n  extends ExposeMethods<TFnData, TVariables> {\n  <TData = TFnData>(\n    options: TVariables extends void\n      ? InfiniteQueryHookOptions<TFnData, Error, TData, TVariables> | void\n      : InfiniteQueryHookOptions<TFnData, Error, TData, TVariables>\n  ): UseInfiniteQueryResult<TData, Error> & {\n    setData: (\n      updater: Updater<\n        InfiniteData<TFnData> | undefined,\n        InfiniteData<TFnData> | undefined\n      >,\n      options?: SetDataOptions\n    ) => InfiniteData<TFnData> | undefined\n  }\n}\n\nexport function createInfiniteQuery<\n  TFnData,\n  TVariables = void,\n  Error = unknown\n>(\n  options: CreateInfiniteQueryOptions<TFnData, TVariables, Error>\n): InfiniteQueryHook<TFnData, TVariables, Error>\n\nexport function createInfiniteQuery<\n  TFnData,\n  TVariables = void,\n  Error = unknown\n>(\n  primaryKey: string,\n  options?: Omit<\n    CreateInfiniteQueryOptions<TFnData, TVariables, Error>,\n    'primaryKey'\n  >\n): InfiniteQueryHook<TFnData, TVariables, Error>\n\nexport function createInfiniteQuery<\n  TFnData,\n  TVariables = void,\n  Error = unknown\n>(\n  primaryKey: string,\n  queryFn: QueryFunction<TFnData, QueryKitKey<TVariables>>,\n  options?: Omit<\n    CreateInfiniteQueryOptions<TFnData, TVariables, Error>,\n    'primaryKey' | 'queryFn'\n  >\n): InfiniteQueryHook<TFnData, TVariables, Error>\n\nexport function createInfiniteQuery<\n  TFnData,\n  TVariables = void,\n  Error = unknown\n>(\n  arg1: any,\n  arg2?: any,\n  arg3?: any\n): InfiniteQueryHook<TFnData, TVariables, Error> {\n  const options = parseQueryKitArgs(arg1, arg2, arg3)\n  return createBaseQuery(options, useInfiniteQuery) as InfiniteQueryHook<\n    TFnData,\n    TVariables,\n    Error\n  >\n}\n","import type {\n  MutationFunction,\n  MutationKey,\n  UseMutationOptions,\n  UseMutationResult,\n} from '@tanstack/react-query'\nimport { parseMutationArgs, useMutation } from '@tanstack/react-query'\n\nexport interface CreateMutationResult<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void\n> {\n  <TContext>(\n    options?: Omit<\n      UseMutationOptions<TData, TError, TVariables, TContext>,\n      'mutationFn' | 'mutationKey'\n    >\n  ): UseMutationResult<TData, TError, TVariables, TContext>\n  getKey: () => MutationKey | undefined\n  mutationFn: MutationFunction<TData, TVariables>\n}\n\nexport function createMutation<\n  TData = unknown,\n  TVariables = void,\n  TError = unknown,\n  TContext = unknown\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>\n): CreateMutationResult<TData, TError, TVariables>\n\nexport function createMutation<\n  TData = unknown,\n  TVariables = void,\n  TError = unknown,\n  TContext = unknown\n>(\n  mutationFn: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationFn'\n  >\n): CreateMutationResult<TData, TError, TVariables>\n\nexport function createMutation<\n  TData = unknown,\n  TVariables = void,\n  TError = unknown,\n  TContext = unknown\n>(\n  mutationKey: MutationKey,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey'\n  >\n): CreateMutationResult<TData, TError, TVariables>\n\nexport function createMutation<\n  TData = unknown,\n  TVariables = void,\n  TError = unknown,\n  TContext = unknown\n>(\n  mutationKey: MutationKey,\n  mutationFn?: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey' | 'mutationFn'\n  >\n): CreateMutationResult<TData, TError, TVariables>\n\nexport function createMutation<\n  TData = unknown,\n  TVariables = void,\n  TError = unknown,\n  TContext = unknown\n>(\n  arg1:\n    | MutationKey\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg2?:\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg3?: UseMutationOptions<TData, TError, TVariables, TContext>\n): CreateMutationResult<TData, TError, TVariables> {\n  const defaultOptions = parseMutationArgs(arg1, arg2, arg3)\n  const getKey = () => defaultOptions.mutationKey\n\n  function useGeneratedMutation(\n    options?: Omit<\n      UseMutationOptions<TData, TError, TVariables, TContext>,\n      'mutationFn' | 'mutationKey'\n    >\n  ) {\n    return useMutation({\n      ...defaultOptions,\n      ...options,\n    })\n  }\n\n  useGeneratedMutation.getKey = getKey\n  useGeneratedMutation.mutationFn = defaultOptions.mutationFn as NonNullable<\n    MutationFunction<TData, TVariables>\n  >\n\n  return useGeneratedMutation as CreateMutationResult<TData, TError, TVariables>\n}\n","import type {\n  QueryFunction,\n  SetDataOptions,\n  UseQueryOptions,\n  UseQueryResult,\n} from '@tanstack/react-query'\nimport { useQuery } from '@tanstack/react-query'\nimport type { Updater } from '@tanstack/react-query/build/types/packages/query-core/src/utils'\nimport { createBaseQuery } from './createBaseQuery'\nimport type {\n  AdditionalCreateOptions,\n  AdditionalQueryHookOptions,\n  ExposeMethods,\n  QueryKitKey,\n} from './types'\nimport { parseQueryKitArgs } from './utils'\n\ninterface CreateQueryOptions<TFnData, TVariables, Error>\n  extends Omit<\n      UseQueryOptions<TFnData, Error, unknown, QueryKitKey<TVariables>>,\n      'queryKey' | 'queryFn' | 'enabled' | 'select'\n    >,\n    AdditionalCreateOptions<TFnData, TVariables> {}\n\ntype QueryHookOptions<TFnData, Error, TData, TVariables> = Omit<\n  UseQueryOptions<TFnData, Error, TData, QueryKitKey<TVariables>>,\n  'queryKey' | 'queryFn' | 'enabled'\n> &\n  AdditionalQueryHookOptions<TFnData, TVariables>\n\ninterface QueryHook<TFnData, TVariables = void, Error = unknown>\n  extends ExposeMethods<TFnData, TVariables> {\n  <TData = TFnData>(\n    options: TVariables extends void\n      ? QueryHookOptions<TFnData, Error, TData, TVariables> | void\n      : QueryHookOptions<TFnData, Error, TData, TVariables>\n  ): UseQueryResult<TData, Error> & {\n    setData: (\n      updater: Updater<TFnData | undefined, TFnData>,\n      options?: SetDataOptions | undefined\n    ) => TFnData | undefined\n  }\n}\n\nexport function createQuery<TFnData, TVariables = void, Error = unknown>(\n  options: CreateQueryOptions<TFnData, TVariables, Error>\n): QueryHook<TFnData, TVariables, Error>\n\nexport function createQuery<TFnData, TVariables = void, Error = unknown>(\n  primaryKey: string,\n  options?: Omit<CreateQueryOptions<TFnData, TVariables, Error>, 'primaryKey'>\n): QueryHook<TFnData, TVariables, Error>\n\nexport function createQuery<TFnData, TVariables = void, Error = unknown>(\n  primaryKey: string,\n  queryFn: QueryFunction<TFnData, QueryKitKey<TVariables>>,\n  options?: Omit<\n    CreateQueryOptions<TFnData, TVariables, Error>,\n    'primaryKey' | 'queryFn'\n  >\n): QueryHook<TFnData, TVariables, Error>\n\nexport function createQuery<TFnData, TVariables = void, Error = unknown>(\n  arg1: any,\n  arg2?: any,\n  arg3?: any\n): QueryHook<TFnData, TVariables, Error> {\n  const options = parseQueryKitArgs(arg1, arg2, arg3)\n  return createBaseQuery(options, useQuery) as QueryHook<\n    TFnData,\n    TVariables,\n    Error\n  >\n}\n"],"names":["createBaseQuery","options","hook","primaryKey","queryFn","defaultOptions","getPrimaryKey","getKey","variables","useGeneratedQuery","restOptions","queryKey","enabled","mergedOptions","queryClient","useQueryClient","context","setData","updater","setQueryData","result","getQueryData","Object","assign","parseQueryKitArgs","arg1","arg2","arg3","createInfiniteQuery","useInfiniteQuery","createMutation","parseMutationArgs","mutationKey","useGeneratedMutation","useMutation","mutationFn","createQuery","useQuery"],"mappings":"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"}